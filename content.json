{"meta":{"title":"YHS努力前行","subtitle":"","description":"","author":"F0rest","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Java学习之设计模式-创建式模式","slug":"Study","date":"2020-11-14T04:56:56.000Z","updated":"2020-11-16T06:51:27.916Z","comments":true,"path":"2020/11/14/Study/","link":"","permalink":"http://example.com/2020/11/14/Study/","excerpt":"","text":"##单例模式所谓单例模式，采取一定的方法保证在整个软件系统中，某个类只能存在一个对象实例，且该类只提供一个取得其对象实例的方法（静态方法）使用场景：需要频繁创建和销毁对象，创建重量级对象，经常用到的对象，工具类对象等1.饿汉式（静态变量）：构造器私有化，在类的加载时候实例化，提供一个方法获取该实例对象优点：写法简单，在类装载的时候完成实例化，避免线程同步问题缺点：没有达到Lazy Loading效果，如果从始至终未用到实例，造成资源浪费2.饿汉式（静态代码块）：与静态变量一致，将实例化放在静态代码块中3.懒汉式（线程不安全）：提供一个静态的公有方法，使用该方法时，才去创建instance优点：起到了Lazy Loading的效果，但只能在单线程下使用缺点：一个线程进入了判断语句块，未来得及往下执行，另一个线程也进入判断语句，导致产生多个实例4.懒汉式（线程安全，同步方法）：提供一个静态的公有方法，添加synchronize同步，解决线程安全问题优点：解决了线程不安全问题缺点：效率很低，多个线程想获得类的实例时候，都要进行同步进去执行，导致效率很低5.懒汉式（线程不安全，同步代码块）：在静态公有方法中，同步机制放在创建实例，没有意义，本意想改进第四步，情况与第三个类似，如果进入了判断语句，对象每次都会被创建，只是时间问题6.双重检查（线程安全）：提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题，解决了第三步的频繁执行synchronize。只需创建一次，其他线程不用经过synchronize，直接判断是否存在实例对象，刚创建的时候可能会有少量线程同时进入。7.静态内部类（线程安全）使用静态内部类的方式，提供一个公有方法，线程可通过公有方法调用静态内部类的生成实例，在类装载时，静态内部类不会执行，而是需要实例化，调用方法时，才会执行静态内部类类的静态属性只会在第一次加载类的时候初始化，jvm在类的初始化时，别的线程无法进入，保证了线程安全性8.枚举能避免多线程同步问题，防止反序列化重新创建对象。简单工厂模式：由一个工厂对象决定创建出哪一种产品类的实例：定义了一个创建对象的类，由这个类来封装实例化对象的行为将客户端和具体产品间插入一个分界线，增加一个工厂，客户端和工厂交互，工厂内部和具体产品交互，具体产品修改时，客户端不会跟着一起进行修改，解耦合。但是：产品增多后，简单工厂就会变得很臃肿，客户端需要扩展具体产品类后，简单工厂需要修改，违反开闭原则?工厂方法模式：当有新的需求，可以创建不同的简单工厂类，考虑到软件的规模，以及软件的可维护性，可扩展性，需要采取工厂方法模式客户端需要扩展具体产品类后，只需要扩展一个新的工厂方法而已但是：如果有多个产品等级，工厂的数量就会跟着增多，每增加一个产品等级，就要增加一个工厂抽象工厂模式：定义一个接口，用于创建相关或有依赖关系的对象簇，无需指明具体的类，可以将简单工厂模式和工厂方法模式整合合并工厂方法的诸多工厂产品等级比较固定时，可以考虑使用抽象工厂、如果产品等级经常变化，则不建议使用抽象工厂。产品等级即是抽象工厂接口类里的方法，如果经常变，则会导致其下的所有实现类都会改变?原型模式：使用Clone方法（实现cloneable接口，重写Object的方法），clone方法不会引起构造器的调用，clone方法时直接复制内存中的二进制，clone出的对象地址不一致浅拷贝：把原来的对象的值，原样复制给clone对象，对于引用类型，把地址值给了clone对象，如果clone对象对引用类型的属性进行修改，原有对象的该引用类型的属性也会被改变深拷贝：把原来对象的值，复制给clone对象，对于引用类型，同样做一次clone，新建了引用类型对象，把引用对象的里面的属性复制给新的引用类型对象，从而使得clone出来的对象中，里面的引用对象和原来对象的引用对象的地址不一样，不会影响如果对象里引用类型里还有引用类型，比较麻烦。使用序列化进行深拷贝：方法重写时，不能抛出比父类更多的异常，只能try catch使用序列化，输出流，对象输出流，把对象写进去，输入流，对象输入流，把对象读出来。序列化时，对象的所有属性层级关系会被序列化自动处理，反序列化，得到一个新的对象，与原来的对象地址不一样问题：序列化的目标位置时写死的，位置不应该写死，Linux下和Windows下的路径格式不一致？OutputStream out = new FileOutputStream(“F:\\a.txt”);ObjectOutputStream oos = new ObjectOutputStream(out);Oos.writeObject(this);Oos.close;InputStream in = new FileInputStream(“F:\\a.txt”);ObjectInputStream ois = new ObjectInputStream(in);Object clone = ois.readObject();Ois.close();?解决：写到内存里ByteArrayOutputStream out = new ByteArrayOutputStream();ObjectOutputStream oos = new ObjectOutputStream(out);?Byte[] bb = out.toByteArray();InputStream in = new ByteArrayInputStream(bb);ObjectInputStream ois = new ObjectInputStream(in);Object clone = ois.readObject();Ois.close();重温IO流！向上转型，子类独有方法失效，需要取消向上转型因此，java里创建对象的四种方法：1.使用构造器；2.反射机制；3.clone方法；4.序列化与反序列化原型模式的注意： 创建新的对象比较复杂时，可以直接使用原型模式简化创建过程，提高效率。 不用重复初始化对象，而是动态获得对象运行时状态 缺点：要为每一个类配置一个克隆方法，对已有的方法进行改造时，要修改其源代码，违反ocp原则建造者模式：由何引出？①客户端需要某个实例，需要自己去对其进行配置属性；违反迪米特法则，因此需要建立一个建造者，将配置工作交付建造者②每一种不同的实例，对应每一种不同的配置属性，但属性类是一样的，做重复的工作，且如果有一个实例建造者漏掉了某一步，该值就会为null，以后就可能出现Np异常，因此需要用一个统一化接口管理创建步骤，即让每个配置建造者去实现创建接口③有了建造者接口，不会遗漏属性配置步骤，每个builder都要调用set方法，代码重复，需要客户端执行创建步骤，可能会遗漏某些步骤，且违反迪米特法则，因此需要指派一个指挥者进行步骤稳定执行④创建指挥者，具体实现建造者接口的各个步骤，根据客户端的需求传入相关属性，其实就相当于把③步骤的创建封装起来。优点： 创建对象的过程是稳定不变的，用一个接口控制稳定过程 创建对象的过程只写了一次，没有重复代码 当需要扩展，不用修改源码，符合开闭原则建造者与工厂模式的区别：工厂模式只需要一个简单的生产产品建造者模式更注重生产出的产品后，对其进行属性赋值的过程","categories":[{"name":"Web学习","slug":"Web学习","permalink":"http://example.com/categories/Web%E5%AD%A6%E4%B9%A0/"},{"name":"Java学习","slug":"Web学习/Java学习","permalink":"http://example.com/categories/Web%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"author":"F0rest"},{"title":"Hello World","slug":"hello-world","date":"2020-11-14T04:02:44.713Z","updated":"2020-11-14T04:02:44.713Z","comments":true,"path":"2020/11/14/hello-world/","link":"","permalink":"http://example.com/2020/11/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Web学习","slug":"Web学习","permalink":"http://example.com/categories/Web%E5%AD%A6%E4%B9%A0/"},{"name":"Java学习","slug":"Web学习/Java学习","permalink":"http://example.com/categories/Web%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}